<!DOCTYPE html>
<meta charset="utf-8">
<style>
  .frame {
    fill: none;
    stroke: #000;
  }
  
  .axis text {
    font: 10px sans-serif;
  }
  
  .axis line,
  .axis circle {
    fill: none;
    stroke: steelblue;
    stroke-dasharray: 4;
  }
  
  .axis:last-of-type circle {
    stroke: steelblue;
    stroke-dasharray: none;
  }
  
  .line {
    fill: none;
    stroke: orange;
    stroke-width: 3px;
  }
</style>

<body>
  <script src="https://d3js.org/d3-shape.v1.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
  <script>
        const width = 960
        const height = 500
    //       radius = Math.min(width, height) / 2 - 30;
    
    // var data = [
    //   [0, 0.4],
    //   [6, 0.2],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    //   [Math.random()*24, Math.random()],
    // ]

    // var y = _.map(data, _.last);
    // var max =  Math.max.apply(null, y);
    // max = Math.ceil(max*10)/10;

    // var angle = d3.scale.linear()
    //     .domain([0, 24])
    //     .range([0, 2 * Math.PI]);

    // var r = d3.scale.linear()
    //       .domain([0, max])
    //       .range([0, radius]);

    const svg = d3.select('body')
        .append('svg')
        .attr('width', width)
        .attr('height', height)

    // var gr = svg.append("g")
    //       .attr("class", "r axis")
    //       .selectAll("g")
    //       .data(r.ticks(max*10).slice(1))
    //       .enter().append("g");

    // gr.append("circle")
    //       .attr("r", r);

    // gr.append("text")
    //     .attr("y", function(d) { return -r(d) - 4; })
    //     .attr("transform", "rotate(20)")
    //     .style("text-anchor", "middle")
    //     .text(function(d) { return d; });

    // var ga = svg.append("g")
    //       .attr("class", "a axis")
    //       .selectAll("g")
    //       .data(d3.range(-90, 270, 45))
    //       .enter().append("g")
    //       .attr("transform", function(d) {
    //         return "rotate(" + d + ")";
    //     });

    // ga.append("line")
    //       .attr("x2", radius);
     
    // ga.append("text")
    //     .attr("x", radius + 6)
    //     .attr("dy", ".35em")
    //     .style("text-anchor", function(d) { return d < 270 && d > 90 ? "end" : null; })
    //     .attr("transform", function(d) {
    //         return d < 270 && d > 90 ? "rotate(180 " + (radius + 6) + ",0)" : null;
    //     })
    //     .text(function(d,i) { return i*3 + ":00" });

    // var color = d3.scale.category20();

    // var line = d3.svg.line.radial()
    //       .angle(function(d) {
    //         return angle(d[0]);
    //       })
    //       .radius(function(d) {
    //         return r(d[1]);
    //       });
      

    // svg.selectAll("point")
    //       .data(data)
    //       .enter()
    //       .append("circle")
    //       .attr("class", "point")
    //       .attr("transform", function(d) {
    //         var coors = line([d]).slice(1).slice(0, -1);
    //         return "translate(" + coors + ")"
    //       })
    //       .attr("r", 8)
    //       .attr("fill",function(d,i){
    //         return color(i);
    //       });
    let moveGridLine
    setPolarCoordinateSystem({})
    function setPolarCoordinateSystem({
        center,
        radius
    }) {
        const r = getRadius(radius)
        drawGridLine(r)
    }

    function drawGridLine(r) {
        const grid = svg.append('g')
            .attr('class', 'grid-lines')
            .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')
        
        grid.on('mousemove', e => {
            const {
                x,
                y
            } = d3.event
            const xBorder = Math.abs(x - width / 2)
            const yBorder = Math.abs(y - height / 2)
            const radius = Math.sqrt( xBorder * xBorder + yBorder * yBorder )
            if (moveGridLine) {
                moveGridLine.attr('r', radius)
                moveGridLine.attr('stroke', () => {
                    if (radius > r) {
                        return 'transparent'
                    }
                    return '#464646'
                })
            } else {
                moveGridLine = grid
                    .append('circle')
                    .attr('cx', 0)
                    .attr('cy', 0)
                    .attr('r', radius)
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '5,5')
                    .attr('stroke', () => {
                        if (radius > r) {
                            return 'transparent'
                        }
                        return '#464646'
                    })
                    .attr('fill', 'transparent')
            }
        })

        for (let i = 1; i < 6; i++) {
            grid.append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', r / 5 * i)
                .attr('stroke-width', '1')
                .attr('stroke', () => {
                    console.log(i)
                    if (i < 5) {
                        return '#dadada'
                    } else {
                        return '#464646'
                    }
                })
                .attr('fill', 'transparent')
        }
    }

    function calcPos(radius, angle) {
        return [ 
            Math.sin(angle) * radius,
            Math.cos(angle) * radius
        ]
    }

    function getRadius(radius) {
        const percentReg = /^(100|[1-9]?\d(\.\d*)?)%$/
        const width = Number(d3.select('svg').attr('width'))
        const height = Number(d3.select('svg').attr('height'))
        let r = Math.min(width, height) / 2 - 2
        if (typeof radius === 'number' &&
        radius > 0) {
            r = radius
        } else if (percentReg.test(radius)) {
            r = Number(percentReg.exec(radius)[1]) * r / 100
        }
        return r
    }

  </script>